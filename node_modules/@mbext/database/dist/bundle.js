var t={d:(e,a)=>{for(var r in a)t.o(a,r)&&!t.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:a[r]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},e={};t.d(e,{A:()=>r});class a extends Error{type;details;constructor(t,e,r){super(e),this.type=t,this.details=r,Object.setPrototypeOf(this,a.prototype),Error.captureStackTrace&&Error.captureStackTrace(this,a),this.name="DatabaseError"}toString(){let t=`${this.name}[${this.type}]: ${this.message}`;return this.details&&(t+=`\nDetails: ${JSON.stringify(this.details,null,2)}`),t}toObject(){return{name:this.name,type:this.type,message:this.message,details:this.details,stack:this.stack}}}class r{collectionName;storageType;collectionValidators;data;constructor(t,e,r){if(this.collectionName=t,this.storageType=e,this.collectionValidators=r,t.length<1||t.length>16)throw new a("INVALID_COLLECTION_NAME","Collection name must be between 1 and 16 characters",{collectionName:t,length:t.length});this.data=new Map,this.initialize()}initialize(){try{const t=this.storageType.getDynamicProperty(this.collectionName);if(t){const e=JSON.parse(t);for(const[t,r]of e){if(!this.validate(r))throw new a("VALIDATION_FAILED","Invalid data found during initialization",{id:t,data:r});this.data.set(t,r)}}}catch(t){if(t instanceof a)throw t;throw new a("INITIALIZATION_ERROR","Failed to initialize database",{originalError:t.message})}}saveChanges(){try{const t=Array.from(this.data.entries());this.storageType.setDynamicProperty(this.collectionName,JSON.stringify(t))}catch(t){throw new a("STORAGE_WRITE_ERROR","Failed to save changes to storage",{originalError:t.message})}}generateId(){let t,e=0;do{if(e>=100)throw new a("DUPLICATE_KEY","Failed to generate unique ID after maximum attempts",{attempts:100});t=Array.from({length:16},(()=>Math.floor(16*Math.random()).toString(16))).join(""),e++}while(this.data.has(t));return t}validate(t){if(!this.collectionValidators)return!0;const e=[];if(!this.collectionValidators)return!0;for(const[a,r]of Object.entries(this.collectionValidators))r&&(r(t[a])||e.push({field:a,error:`Validation failed for field ${a}`}));if(e.length>0)throw new a("VALIDATION_FAILED","Data validation failed",{validationErrors:e});return!0}evaluateCondition(t,e){try{const r=t[e.field],i=e.value;switch(e.operator){case"==":return r===i;case"!=":return r!==i;case">":return r>i;case"<":return r<i;case">=":return r>=i;case"<=":return r<=i;case"contains":return String(r).toLowerCase().includes(String(i).toLowerCase());case"startsWith":return String(r).toLowerCase().startsWith(String(i).toLowerCase());case"endsWith":return String(r).toLowerCase().endsWith(String(i).toLowerCase());default:throw new a("INVALID_QUERY","Invalid operator in filter condition",{operator:e.operator})}}catch(t){if(t instanceof a)throw t;throw new a("INVALID_QUERY","Error evaluating filter condition",{condition:e,originalError:t.message})}}clear(){try{this.data.clear(),this.saveChanges()}catch(t){if(t instanceof a)throw t;throw new a("STORAGE_WRITE_ERROR","Failed to clear database",{originalError:t.message})}}create(t){try{this.validate(t);const e=this.generateId();return this.data.set(e,t),this.saveChanges(),e}catch(t){if(t instanceof a)throw t;throw new a("UNKNOWN_ERROR","Failed to create document",{originalError:t.message})}}createMany(t){try{const e=[];return t.forEach(((t,e)=>{try{this.validate(t)}catch(r){throw new a("VALIDATION_FAILED",`Validation failed for item at index ${e}`,{index:e,item:t,originalError:r})}})),t.forEach((t=>{const a=this.generateId();this.data.set(a,t),e.push(a)})),this.saveChanges(),e}catch(t){if(t instanceof a)throw t;throw new a("UNKNOWN_ERROR","Failed to create multiple documents",{originalError:t.message})}}update(t,e){const r=this.data.get(t);if(!r)throw new a("DOCUMENT_NOT_FOUND","Document not found for update",{id:t});const i={...r,...e};try{this.validate(i),this.data.set(t,i),this.saveChanges()}catch(e){if(e instanceof a)throw e;throw new a("INVALID_UPDATE","Failed to update document",{id:t,originalError:e.message})}}updateMany(t){const e=new Map(this.data);try{t.forEach((({id:t,data:e},r)=>{const i=this.data.get(t);if(!i)throw new a("DOCUMENT_NOT_FOUND",`Document not found for update at index ${r}`,{index:r,id:t});const o={...i,...e};try{this.validate(o)}catch(i){throw new a("VALIDATION_FAILED",`Validation failed for update at index ${r}`,{index:r,id:t,data:e,originalError:i})}})),t.forEach((({id:t,data:e})=>{const a=this.data.get(t);this.data.set(t,{...a,...e})})),this.saveChanges()}catch(t){if(this.data=e,t instanceof a)throw t;throw new a("INVALID_UPDATE","Failed to update multiple documents",{originalError:t.message})}}delete(t){if(!this.data.has(t))throw new a("DOCUMENT_NOT_FOUND","Document not found for deletion",{id:t});try{this.data.delete(t),this.saveChanges()}catch(e){if(e instanceof a)throw e;throw new a("STORAGE_WRITE_ERROR","Failed to delete document",{id:t,originalError:e.message})}}deleteMany(t){const e=new Map(this.data);try{t.forEach(((t,e)=>{if(!this.data.has(t))throw new a("DOCUMENT_NOT_FOUND",`Document not found for deletion at index ${e}`,{index:e,id:t})})),t.forEach((t=>this.data.delete(t))),this.saveChanges()}catch(t){if(this.data=e,t instanceof a)throw t;throw new a("STORAGE_WRITE_ERROR","Failed to delete multiple documents",{originalError:t.message})}}findById(t){const e=this.data.get(t);if(!e)throw new a("DOCUMENT_NOT_FOUND","Document not found",{id:t});return{id:t,data:e}}findOne(t){try{const e=this.findMany(t)[0];if(!e)throw new a("DOCUMENT_NOT_FOUND","No document found matching predicate");return e}catch(t){if(t instanceof a)throw t;throw new a("INVALID_QUERY","Error executing findOne query",{originalError:t.message})}}findMany(t){try{return t?Array.from(this.data.entries()).filter((([e,a])=>t(a))).map((([t,e])=>({id:t,data:e}))):Array.from(this.data.entries()).map((([t,e])=>({id:t,data:e})))}catch(t){if(t instanceof a)throw t;throw new a("INVALID_QUERY","Error executing findMany query",{originalError:t.message})}}findLike(t,e){try{const a=t.toLowerCase();return Array.from(this.data.entries()).filter((([t,r])=>(e||Object.keys(r)).some((t=>{try{return String(r[t]).toLowerCase().includes(a)}catch{return!1}})))).map((([t,e])=>({id:t,data:e})))}catch(r){if(r instanceof a)throw r;throw new a("INVALID_QUERY","Error executing findLike query",{term:t,fields:e,originalError:r.message})}}query(t,e,r){try{if(!Array.isArray(t))throw new a("INVALID_QUERY","Conditions must be an array",{conditions:t});let i=Array.from(this.data.entries()).filter((([e,a])=>t.every((t=>this.evaluateCondition(a,t)))));if(e){const t=Object.entries(e);i.sort((([e,a],[r,i])=>{for(const[e,r]of t){const t=a[e],o=i[e];if(t===o)continue;const n=t<o?-1:1;return"asc"===r?n:-n}return 0}))}if(void 0!==r){if(r<0)throw new a("INVALID_QUERY","Limit must be a non-negative number",{limit:r});i=i.slice(0,r)}return i.map((([t,e])=>({id:t,data:e})))}catch(i){if(i instanceof a)throw i;throw new a("INVALID_QUERY","Query execution failed",{conditions:t,sort:e,limit:r,originalError:i.message})}}export(){try{return JSON.stringify(Array.from(this.data.entries()))}catch(t){throw new a("EXPORT_ERROR","Failed to export database",{originalError:t.message})}}import(t){try{const e=JSON.parse(t),r=e.filter((([t,e])=>{try{return this.validate(e)}catch(t){return!1}}));if(r.length!==e.length)throw new a("VALIDATION_FAILED","Some entries failed validation during import",{totalEntries:e.length,validEntries:r.length,invalidEntries:e.length-r.length});this.clear();for(const[t,e]of r)this.data.set(t,e);this.saveChanges()}catch(t){if(t instanceof a)throw t;throw new a("IMPORT_ERROR","Failed to import data",{originalError:t.message})}}}var i=e.A;export{i as default};